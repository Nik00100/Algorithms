package test_kontur.competition.chatty_done;

/*D. Общительный человек
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт

Игнат позиционирует себя как общительный человек, поэтому у него много друзей. Недавно Игнат и его друзья придумали новый способ
генерации случайных чисел. Способ заключается в том, что каждый из N  друзей Игната берет кубик и записывает на всех его гранях
какие-то целые числа (не обязательно различные). После этого все друзья одновременно кидают свои кубики, а Игнат складывает все
выпавшие на кубиках числа. Получившаяся сумма и будет случайным сгенерированным числом.

Игнату интересно, сколько различных целых чисел он может получить таким способом.

Входные данные
В первой строке содержится целое число N — количество друзей Игната (3≤N≤100). В i-й из следующих N строк содержатся целые
числа ai1,ai2,ai3,ai4,ai5,ai6 — числа, записанные на гранях кубика i-го друга (0≤aij≤500).

Выходные данные
Выведите количество различных целых чисел, которые могут быть получены с помощью описанного способа генерации случайных чисел.

Система оценки
В этой задаче 3 группы тестов.
Первая группа тестов стоит 4 балла, для нее выполняется ограничение N=3.
Вторая группа тестов стоит 3 балла, для нее выполняется ограничение N≤9.
Третья группа тестов стоит 3 балла, для нее выполняется ограничение N≤100.

Пример
входные данные
3
0 1 2 3 4 5
0 0 2 3 4 5
3 4 5 0 0 0
выходные данные
16

Примечание
В примере описанным способом можно получить любое целое число от 0 до 15 включительно.
*/

import java.io.*;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine());
        int[][] numbers = new int[n][6];
        int[] maxNum = new int[n];

        for (int i = 0; i < n; i++) {
            maxNum[i] = -1;
            String[] s = reader.readLine().split(" ");
            for (int j = 0; j < 6; j++) {
                numbers[i][j] = Integer.parseInt(s[j]);
                maxNum[i] = Math.max(maxNum[i], numbers[i][j]);
            }
        }

        int maxSum = 0;
        for (int i = 0; i < n; i++) {
            maxSum += maxNum[i];
        }

        int[][] dp = new int[2][maxSum + 1];
        for (int i = 1; i <= maxSum; i++) {
            dp[1][i] = 0;
        }
        dp[1][0] = 1;

        for (int i = 0; i < n; i++) {
            int cur = i & 1;
            int last = (i + 1) & 1;
            for (int k = 0; k <= maxSum; k++) {
                dp[cur][k] = 0;
            }
            for (int edge = 0; edge < 6; edge++) {
                int x = numbers[i][edge];
                for (int j = 0; j <= maxSum - x; j++) {
                    if (dp[last][j] > 0) {
                        dp[cur][j + x] = 1;
                    }
                }
            }
        }

        int count = 0;
        for (int k = 0; k <= maxSum; k++) {
            count += dp[(n - 1) & 1][k];
        }
        System.out.println(count);

        reader.close();
    }
}
