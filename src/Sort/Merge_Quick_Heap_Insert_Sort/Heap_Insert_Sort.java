package Sort.Merge_Quick_Heap_Insert_Sort;

import java.util.Arrays;

public class Heap_Insert_Sort {

    // Алгоритм сортировки вставкой:
    // Перебираются элементы в неотсортированной части массива.
    // Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.
    // Худшее время	(n^2), Лучшее время	O(n) если массив почти отсортирован, Среднее время O(n^2)
    // Худшее время	(n\log n), Лучшее время	O(n\log n), Среднее время O(n\log n)
    static void insertionSort(int[] nums){
        if(nums.length <= 1) return;
        for(int i = 1; i < nums.length; i++){
            // элемент отправляется в буфер
            int tmp = nums[i];
            // слева от элемента накапливается отсортированная часть
            int j = i - 1;
            // поиск места для вставки
            while(j >= 0 && nums[j] > tmp){
                nums[j + 1] = nums[j];
                j--;
            }
            nums[j + 1] = tmp;
        }
    }

    static class HeapSort {
        // Алгоритм пирамидальной сортировки:
        //  1. Построить max-heap из входных данных (значение в родительском узле больше значений в его двух дочерних).
        //  2. На данном этапе самый большой элемент хранится в корне кучи. Замените его на последний элемент кучи,
        //      а затем уменьшите ее размер на 1. Наконец, преобразуйте полученное дерево в max-heap с новым корнем.
        //  3. Повторяйте вышеуказанные шаги, пока размер кучи больше 1.
        // Если родительский узел хранится в индексе I, левый дочерний элемент может быть вычислен как 2 I + 1,
        // а правый дочерний элемент — как 2 I + 2 (при условии, что индексирование начинается с 0).
        // Худшее время	(n\log n), Лучшее время	O(n\log n), Среднее время O(n\log n)

        public void heapSort(int[] nums) {
            int n = nums.length;

            // Построение кучи, максимальный элемент окажется в корне.
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(nums, n, i);

            // Один за другим извлекаем элементы из кучи
            for (int i=n-1; i>=0; i--) {
                // Перемещаем текущий корень в конец
                int temp = nums[0];
                nums[0] = nums[i];
                nums[i] = temp;

                // Вызываем процедуру heapify на уменьшенной куче
                heapify(nums, i, 0);
            }
        }

        // Метод для преобразования в двоичную кучу поддерева с корневым узлом i,
        // i - индекс элемента в nums[], n - размер кучи
        void heapify(int[] nums, int n, int i) {
            int largest = i; // Инициализируем наибольший элемент как корень
            int l = 2*i + 1; // левый = 2*i + 1
            int r = 2*i + 2; // правый = 2*i + 2

            // Если левый дочерний элемент больше корня
            if (l < n && nums[l] > nums[largest])
                largest = l;

            // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
            if (r < n && nums[r] > nums[largest])
                largest = r;
            // Если самый большой элемент не корень
            if (largest != i) {
                int swap = nums[i];
                nums[i] = nums[largest];
                nums[largest] = swap;

                // Рекурсивно преобразуем в двоичную кучу затронутое поддерево
                heapify(nums, n, largest);
            }
        }

    }



    public static void main(String[] args) {
        int[] nums = {5,1,1,2,0,0};
        //insertionSort(nums);
        new HeapSort().heapSort(nums);
        System.out.println(Arrays.toString(nums));

    }
}
