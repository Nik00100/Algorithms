package ya_training.algo1_0.task7.advertisment;

/*Фирма NNN решила транслировать свой рекламный ролик в супермаркете XXX. Однако денег, запланированных на рекламную кампанию,
хватило лишь на две трансляции ролика в течение одного рабочего дня.
Фирма NNN собрала информацию о времени прихода и времени ухода каждого покупателя в некоторый день. Менеджер по рекламе предположил,
что и на следующий день покупатели будут приходить и уходить ровно в те же моменты времени.
Помогите ему определить моменты времени, когда нужно включить трансляцию рекламных роликов, чтобы как можно большее количество
покупателей прослушало ролик целиком от начала до конца хотя бы один раз. Ролик длится ровно 5 единиц времен. Трансляции роликов
не должны пересекаться, то есть начало второй трансляции должно быть хотя бы на 5 единиц времени позже, чем начало первой.

Если трансляция ролика включается, например, в момент времени 10, то покупатели, пришедшие в супермаркет в момент времени 10
(или раньше) и уходящие из супермаркета в момент 15 (или позднее) успеют его прослушать целиком, а, например, покупатель,
пришедший в момент времени 11, равно как и покупатель, уходящий в момент 14 - не успеют. Если покупатель успевает услышать
только конец первой трансляции ролика (не сначала) и начало второй трансляции (не до конца), то считается, что он не услышал
объявления. Если покупатель успевает услышать обе трансляции ролика, то при подсчете числа людей, прослушавших ролик, он все
равно учитывается всего один раз (фирме важно именно количество различных людей, услышавших ролик).

Формат ввода
В первой строке входного файла вводится число N - количество покупателей (1 ≤ N ≤ 2000). В следующих N строках записано по паре
натуральных чисел - время прихода и время ухода каждого из них. Все значения времени - натуральные числа, не превышающие 10^9.
Время ухода человека из супермаркета всегда строго больше времени его прихода в супермаркет.

Формат вывода
Выведите через пробел три числа: количество покупателей, которые прослушают ролик целиком от начала до конца хотя бы один раз,
и моменты времени, когда должна начинаться трансляция ролика. Моменты времени должны быть выведены в возрастающем порядке
и должны быть натуральными числами, не превышающими 2·10^9. Если вариантов ответа несколько, выведите любой из них.

Пример 1
Ввод
4
1 11
1 3
6 15
1 6
Вывод
3 1 6

Пример 2
Ввод
1
1 10
Вывод
1 3 25

Пример 3
Ввод
3
1 10
11 20
21 30
Вывод
2 1 22

Примечания
1. Трансляция роликов начинается в моменты времени 1 и 6. Первое объявление успевают прослушать покупатели номер 1 и 4, второе - 1 и 3.
Когда бы ни начиналась трансляция объявления, 2-й покупатель не сможет его прослушать, так как находится в супермаркете менее 5 минут.
Приведенный ответ является не единственным верным ответом на этот тест.

2. Объявление, трансляция которого начинается в момент 3, единственный покупатель обязательно услышит. Вторую трансляцию
(раз она оплачена) мы можем сделать когда угодно, например, в 25 минут в пустом супермаркете (впрочем, мы не можем начать
трансляцию второго объявления, например, в момент 7 - т.к. к этому моменту еще не закончится первая трансляция)

3. Объявление услышат лишь 2 из 3-х покупателей.*/


// фишка - схлопнуть отрезки на время рекламы
// фишка - понимать по ограничениям какая сложность алгоритма зайдет, если 2000, то O(N2) вполне за 1 секунду
// по задаче - для каждого покупателя запускать первый ролик по его приходу и относительно него искать запуск второго, при чем для второго можно по событию ухода. цикл в цикле. Во втором цикле не учитывать тех кто учтен в первом.
// ограничения - ни одного, один максимальный. Ролики не должны пересекаться

import java.io.*;
import java.util.*;

public class Main {
    enum Type {
        IN(-1),
        OUT(2000_000_000);
        private int num;
        Type(int num) {
            this.num = num;
        }
        public int getNum() {
            return num;
        }
    }

    static class CustomerEvent {
        int time;
        Type type;
        int id;
        public CustomerEvent(int time, Type type, int id) {
            this.time = time;
            this.type = type;
            this.id = id;
        }
        @Override
        public String toString() {return "{" + "time=" + time + ", type=" + type + ", id=" + id + '}';}
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("input8.txt")));

        int n = Integer.parseInt(reader.readLine());

        List<CustomerEvent> events = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            String[] inOut = reader.readLine().split(" ");
            // интересны события когда покупатель зашел и за 5 минут до того как вышел
            // в эти моменты есть возможность показать ему ролик
            // и если длительность пребывания в магазине больше 5 минут
            int in = Integer.parseInt(inOut[0]);
            int out = Integer.parseInt(inOut[1]);
            int duration = out - in;

            if (duration >= 5) {
                events.add(new CustomerEvent(in, Type.IN, i));
                events.add(new CustomerEvent(out - 5, Type.OUT, i));
            }
        }



        // сортируем
        Collections.sort(events, (a,b) -> a.time == b.time ? a.type.getNum() - b.type.getNum() : a.time - b.time);

        // если интересных событий нет, то выводим 0 и произвольные два момента времени включения рекламы
        if (events.size() == 0) {
            System.out.println(0 + " " + 10 + " " + 20);
        } else if (events.size() == 2) { //если был 1 человек, то включаем 1ую рекламу в момент прихода и 2ую в произвольный момент
            System.out.println(1 + " " + events.get(0).time + " " + (events.get(0).time + 10));
        } else {
            int bestAns = 0; // ответ по количеству покупателей
            int firstBest = 0; // когда включаем первую рекламу
            int secondBest = 0; // когда включаем вторую рекламу

            // множество возможных покупателей, увидевших первую рекламу
            Set<Integer> firstAd = new HashSet<>();
            for (int i=0; i<events.size(); i++) {
                CustomerEvent event1 = events.get(i); // пытаемся включить первый ролик
                // добавляем покупателя в множество, если покупатель только зашел
                if (event1.type.equals(Type.IN)) {
                    firstAd.add(event1.id);
                    // если получается, что все люди будут смотреть 1ый ролик, но не посмотрят 2ой
                    // то второй мы включаем в произвольный период event1.time + 5
                    if (firstAd.size() > bestAns) {
                        bestAns = firstAd.size();
                        firstBest = event1.time;
                        secondBest = event1.time + 5;
                    }
                }

                if (event1.type.equals(Type.OUT)) { // человек ушел
                    firstAd.remove(event1.id);
                }

                int secondAd = 0; // здесь достаточно только счетчика для количества увидевших вторую рекламу
                for (int j = i+1; j<events.size(); j++) {
                    CustomerEvent event2 = events.get(j);

                    if (event2.type.equals(Type.IN) && !firstAd.contains(event2.id)) {
                        secondAd++; // пытаемся включить второй ролик для людей, которые не видели первый
                    }
                    // разница между первой и второй рекламой хотя бы 5 минут
                    // и количество просмотров первой и второй рекламы > ответа
                    // обновляем значения (общее кол-во людей, время)
                    if (event2.time - event1.time >= 5 && firstAd.size() + secondAd > bestAns) {
                        bestAns = firstAd.size() + secondAd;
                        firstBest = event1.time;
                        secondBest = event2.time;
                    }
                    if (event2.type.equals(Type.OUT) && !firstAd.contains(event2.id)) {
                        secondAd--; // уменьшаем счетчик людей для 2ого ролика
                    }
                }
            }

            System.out.println(bestAns + " " + firstBest + " " + secondBest);
        }

        reader.close();
    }
}
