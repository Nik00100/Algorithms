package ya_training.algo1_0.task5.tourism;

/*Александр недавно увлекся горным туризмом. Ему уже надоело покорять отдельные горные пики, и он собирается покорить
самую настоящую горную цепь!

Напомним, что Александр живет в плоском мире. Горная цепь состоит из отрезков, соединяющих точки на плоскости,
каждая из которых находится строго правее предыдущей (x-координата следующей точки больше, чем у предыдущей).
Трассой на горной цепи называется её часть между двумя фиксированными концами отрезков.

Участок, на котором при движении по трассе координата y (высота) всегда возрастает, называется подъемом, величиной
подъема называется разность высот между начальной и конечной точками участка.

Туристическая компания предлагает на выбор несколько трасс на одной горной цепи. Александр из-за финансовых трудностей
может выбрать для поездки только одну из этих трасс. Вы решили помочь ему с выбором. Александру важно для каждой трассы
определить суммарную высоту подъемов на ней. Обратите внимание, что трасса может идти как слева-направо, так и справа-налево.

Формат ввода
В первой строке входного файла содержится единственное число N — количество точек ломаной, задающей горную цепь (1≤N≤30000).
Далее в N строках содержатся описания точек, каждое из которых состоит из двух целых чисел, xi и yi (1≤xi,yi≤30000).

В следующей строке находится число M — количество трасс (1≤M≤30000).

Далее в M строках содержатся описания трасс. Каждое описание представляет собой два целых числа, si и fi, они обозначают
номера вершин начала и конца трассы, соответственно (1≤si≤N, 1≤fi≤N). Начало и конец трассы могут совпадать.

Гарантируется, что во входном файле задана именно горная цепь.

Формат вывода
Для каждой трассы выведите одно число — суммарную высоту подъемов на данной трассе.

Пример 1
Ввод
7
2 1
4 5
7 4
8 2
9 6
11 3
15 3
1
2 6
Вывод
4
Пример 2
Ввод
6
1 1
3 2
5 6
7 2
10 4
11 1
3
5 6
1 4
4 2
Вывод
0
5
4*/

import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine());

        int[] N = new int[n];
        for (int i = 0; i < n; i++) {
            String[] sN = reader.readLine().split(" ");
            N[i] = Integer.parseInt(sN[1]);
        }

        int m = Integer.parseInt(reader.readLine());
        int[][] M = new int[m][2];
        for (int i = 0; i < m; i++) {
            String[] sM = reader.readLine().split(" ");
            M[i][0] = Integer.parseInt(sM[0]);
            M[i][1] = Integer.parseInt(sM[1]);
        }

        int[] ans = new int[m];
        int[] ansUp = new int[n+1];
        int[] ansDown = new int[n+1];

        // пройдемся один раз по всему массиву вперед и создадим два префиксных массива
        // для трассы при проходе "вверх" и для трассы для прохода "вниз" (по массиву N)

        for (int i = 1; i < n; i++) {
            int h = N[i] - N[i-1];
            if (h > 0) {
                ansUp[i] = ansUp[i - 1] + h;
                ansDown[i] = ansDown[i - 1];
            } else {
                ansDown[i] = ansDown[i - 1] - h;
                ansUp[i] = ansUp[i - 1];
            }
        }

        for (int i = 0; i<m; i++) {
            int start = M[i][0] - 1;
            int finish = M[i][1] - 1;
            if (start > finish) {
                // вниз
                //ans[i] = -ansDown[finish + 1...start].reduce(0, +)
                ans[i] = ansDown[start] - ansDown[finish] >= 0 ? ansDown[start] - ansDown[finish] : 0;
            } else {
                // вверх
                //ans[i] = ansUp[start + 1...finish].reduce(0, +)
                ans[i] = ansUp[finish] - ansUp[start] >= 0 ? ansUp[finish] - ansUp[start] : 0;
            }
        }
        Arrays.stream(ans).boxed().forEach(System.out::println);
        reader.close();
    }
}
