package ya_training.algo1_0.task5.beauty;

/*В парке города Питсбурга есть чудесная аллея, состоящая из N посаженных в один ряд деревьев, каждое одного из K сортов.
В связи с тем, что Питсбург принимает открытый чемпионат Байтландии по программированию, было решено построить огромную арену
для проведения соревнований. Так, согласно этому плану вся аллея подлежала вырубке. Однако министерство деревьев и кустов
воспротивилось этому решению, и потребовало оставить некоторые из деревьев в покое. Согласно новому плану строительства все
деревья, которые не будут вырублены, должны образовывать один непрерывный отрезок, являющийся подотрезком исходного.
Каждого из K видов деревьев требуется сохранить хотя бы по одному экземпляру. На вас возложена задача найти отрезок наименьшей
длины, удовлетворяющий указанным ограничениям.

Формат ввода
В первой строке входного файла находятся два числа N и K (1≤ N, K ≤250000). Во второй строке входного файла следуют N чисел
(разделенных пробелами), i-ое число второй строки задает цвет i-ого слева дерева в аллее. Гарантируется, что присутствует хотя
бы одно дерево каждого цвета

Формат вывода
В выходной файл выведите два числа, координаты левого и правого концов отрезка минимальной длины, удовлетворяющего условию.
Если оптимальных ответов несколько, выведите любой.

Пример 1
Ввод	Вывод
5 3
1 2 1 3 2

2 4
Пример 2
Ввод	Вывод
6 4
2 4 2 3 3 1

2 6*/

import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] s = reader.readLine().split(" ");
        int n = Integer.parseInt(s[0]);
        int k = Integer.parseInt(s[1]);

        String[] sN = reader.readLine().split(" ");
        int[] N = new int[n];
        for (int i = 0; i < n; i++) {
            N[i] = Integer.parseInt(sN[i]);
        }

        int minCount = n; // минимальная последовательность
        int[] ans = new int[] {0, n - 1}; // найденные индексы

        int r = 0;// правый указатель
        Map<Integer,Integer> dict = new HashMap<>(); // есть ли у нас такой цвет и сколько раз
        for(int l=0; l<n; l++) {
            while (r<n && dict.size() < k) {
                int cur = N[r];
                dict.put(cur, dict.getOrDefault(cur,0) + 1);
                r++;
            }

            if (dict.size() == k) {
                // последовательность собралась
                if (minCount > r - l) {
                    minCount = r - l;
                    ans[0] = l;
                    ans[1] = r-1;
                }
            }
            int cur = N[l];
            dict.put(cur, dict.getOrDefault(cur,0) - 1);
            if (dict.get(cur) == 0) {
                dict.remove(cur);
            }
        }
        System.out.println((ans[0]+1) + " " + (ans[1]+1));
        reader.close();
    }
}
