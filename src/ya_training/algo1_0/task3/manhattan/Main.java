package ya_training.algo1_0.task3.manhattan;

/*Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто метров проходит авеню, с запада на
восток через каждые сто метров проходит улица. Авеню и улицы нумеруются целыми числами. Меньшие номера соответствуют западным
авеню и южным улицам. Таким образом, можно построить прямоугольную систему координат так, чтобы точка (x, y) лежала на
пересечении x-ой авеню и y-ой улицы. Легко заметить, что для того, чтобы в Нью-Манхэттене дойти от точки (x1, y1) до
точки (x2, y2) нужно пройти |x2 − x1| + |y2 − y1| кварталов. Эта величина называется манхэттенским расстоянием между
точками (x1, y1) и (x2, y2).

Миша живет в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает из своего дома, который находится в
точке (0, 0) и бежит по случайному маршруту. Каждую минуту Миша либо остается на том же перекрестке, что и минуту назад,
или перемещается на один квартал в любом направлении. Чтобы не заблудиться Миша берет с собой навигатор, который каждые
t минут говорит Мише, в какой точке он находится. К сожалению, навигатор показывает не точное положение Миши, он может
показать любую из точек, манхэттенское расстояние от которых до Миши не превышает d.

Через t × n минут от начала пробежки, получив n-е сообщение от навигатора, Миша решил, что пора бежать домой. Для этого
он хочет понять, в каких точках он может находиться. Помогите Мише сделать это.

Формат ввода
Первая строка входного файла содержит числа t, d и n (1 ≤ t ≤ 100, 1 ≤ d ≤ 100, 1 ≤ n ≤ 100).

Далее n строк описывают данные, полученные от навигатора. Строка номер i содержит числа xi и yi — данные, полученные от
навигатора через ti минут от начала пробежки.

Формат вывода
В первой строке выходного файла выведите число m — число точек, в которых может находиться Миша. Далее выведите m пар
чисел — координаты точек. Точки можно вывести в произвольном порядке.

Гарантируется, что навигатор исправен и что существует по крайней мере одна точка, в которой может находиться Миша.

Пример 1
Ввод
2 1 5
0 1
-2 1
-2 3
0 3
2 5
Вывод
2
1 5
2 4
Пример 2
Ввод
1 1 1
0 0
Вывод
5
-1 0
0 -1
0 0
0 1
1 0
Пример 3
Ввод
1 10 1
0 0
Вывод
5
-1 0
0 -1
0 0
0 1
1 0

                            *           *
                        *                   *
                    *                           *
Эта диагональ описывается ур-ем                 Эта диагональ описывается ур-ем
            x-y = const                                     x+y = const
нам нужно отслеживать пересечение двух множеств - область бегуна о область навигатора

Пример для одного шага и следующих исходных данных:
    - за один шаг (время между сообщениями навигатора) бегун может пробежать 2 квартала (t=2)
    - погрешность навигатора 1 (d=1)
    - координаты, переданные навигатором (2,2)
                                        y
                                        |
                                        |
                                        *   ^
                                      * | * ^ ^
               ---------------------*-*-|-*-*-----------------  x
                                      * | *
                                        *
                                        |
                        * - точки, где за два шага может находиться бегун
                        ^ - (2,2) переданная точка навигатора, и другие точки с учетом погрешности
            В таком случае искомыми будут две точки (где области пересекаются) - (1,1) и (0,2)

            Система уравнений бегуна:
            |   xmax + y = 2                                                нам подходят только Х, делящиеся цело на 2
            |   xmin + y = -2       xmax = ((xmax + y)+(xmax - y)) / 2      иначе - это означает, что бегун находится между
            |   xmax - y = 2        y = const - xmax                        перекрестками, а ему нужно точно знать
            |   xmin - y = -2                                               пересечение улицы и авеню
*/

import java.io.*;
import java.util.*;

public class Main {

    // расширение области rect на diff за каждый шаг
    static void extend(int[] rect, int diff) {
        // минимальные и максимальные координаты
        rect[0] -=diff;
        rect[1] +=diff;
        rect[2] -=diff;
        rect[3] +=diff;
    }

    static int[] intersect (int[] r1, int[] r2) throws InvalidPropertiesFormatException {
        if (r1.length != r2.length) throw new InvalidPropertiesFormatException("Неверно заданы координаты прямоугольников");
        int[] ans = new int[r1.length];
        ans[0] = Math.max(r1[0], r2[0]);
        ans[1] = Math.min(r1[1], r2[1]);
        ans[2] = Math.max(r1[2], r2[2]);
        ans[3] = Math.min(r1[3], r2[3]);
        return ans;
    }


    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] s = reader.readLine().split(" ");
        int t = Integer.parseInt(s[0]);
        int d = Integer.parseInt(s[1]);
        int n = Integer.parseInt(s[2]);

        // начальная позиция бегуна
        int[] posRect = new int[] {0,0,0,0};
        for (int i=0; i<n; i++) {
            // расширяем область бегуна на t за каждый шаг
            extend(posRect, t);

            // вычисляем область навигатора
            String[] nav = reader.readLine().split(" ");
            // переданные координаты
            int navX = Integer.parseInt(nav[0]);
            int navY = Integer.parseInt(nav[1]);
            // область с учетом погрешности
            int[] navRect = new int[] {navX+navY, navX+navY, navX-navY, navX-navY};
            extend(navRect, d);
            posRect = intersect(posRect,navRect);
        }

        //System.out.println(Arrays.stream(posRect).boxed().toList());

        Set<String> result = new HashSet<>();
        // вычисляем координаты x и y - где пересекаются два множества
        for (int xPlusY = posRect[0]; xPlusY < posRect[1] + 1; xPlusY++) { // берем поочередно (xmax + y) и (xmin + y)
            for (int xMinusY = posRect[2]; xMinusY < posRect[3] +1; xMinusY++) { // берем поочередно (xmax - y) и (xmin - y)
                if ((xPlusY + xMinusY) % 2 == 0) {
                    StringBuilder sb =new StringBuilder();
                    int x = (xPlusY + xMinusY) / 2;
                    int y = xPlusY - x;
                    sb.append(x).append(" ").append(y);
                    result.add(sb.toString());
                }
            }
        }

        System.out.println(result.size());
        for (String str : result) {
            System.out.println(str);
        }

        reader.close();
    }
}
