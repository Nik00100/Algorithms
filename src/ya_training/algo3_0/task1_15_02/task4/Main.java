package ya_training.algo3_0.task1_15_02.task4;

/*К тупику со стороны пути 1 (см. рисунок) подъехал поезд. Разрешается отцепить от поезда один или сразу несколько первых вагонов
и завезти их в тупик (при желании, можно даже завезти в тупик сразу весь поезд). После этого часть из этих вагонов вывезти в
сторону пути 2. После этого можно завезти в тупик еще несколько вагонов и снова часть оказавшихся вагонов вывезти в сторону пути 2.
И так далее (так, что каждый вагон может лишь один раз заехать с пути 1 в тупик, а затем один раз выехать из тупика на путь 2).
Заезжать в тупик с пути 2 или выезжать из тупика на путь 1 запрещается. Нельзя с пути 1 попасть на путь 2, не заезжая в тупик.

Известно, в каком порядке изначально идут вагоны поезда. Требуется с помощью указанных операций сделать так, чтобы вагоны поезда
шли по порядку (сначала первый, потом второй и т.д., считая от головы поезда, едущего по пути 2 в сторону от тупика).
Напишите программу, определяющую, можно ли это сделать.

Формат ввода
Вводится число N — количество вагонов в поезде (1 ≤ N ≤ 100). Дальше идут номера вагонов в порядке от головы поезда,
едущего по пути 1 в сторону тупика. Вагоны пронумерованы натуральными числами от 1 до N, каждое из которых встречается
ровно один раз.

Формат вывода
Если сделать так, чтобы вагоны шли в порядке от 1 до N, считая от головы поезда, когда поезд поедет по пути 2 из тупика, можно,
выведите сообщение YES, если это сделать нельзя, выведите NO.

Пример 1
Ввод	Вывод
3
3 2 1

YES
Пример 2
Ввод	Вывод
4
4 1 3 2

YES
Пример 3
Ввод	Вывод
3
2 3 1

NO*/

import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(reader.readLine());
        String[] s = reader.readLine().split(" ");
        Stack<Integer> stack = new Stack<>();

        boolean couldntSort = false;
        int next = 1;
        for (int i = 0; i < n; i++) {
            int num = Integer.parseInt(s[i]);
            if (num == next) {
                next++;
                while (!stack.isEmpty() && stack.peek() == next) {
                    stack.pop();
                    next++;
                }
                continue;
            }

            if (!stack.isEmpty() && num > stack.peek()) {
                couldntSort = true;
                break;
            }

            stack.push(num);
        }

        if (couldntSort) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }

        reader.close();
    }
}
