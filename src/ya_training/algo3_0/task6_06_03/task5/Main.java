package ya_training.algo3_0.task6_06_03.task5;

/*Метрополитен состоит из нескольких линий метро. Все станции метро в городе пронумерованы натуральными числами от 1 до N.
На каждой линии расположено несколько станций. Если одна и та же станция расположена сразу на нескольких линиях,
то она является станцией пересадки и на этой станции можно пересесть с любой линии, которая через нее проходит,
на любую другую (опять же проходящую через нее).

Напишите программу, которая по данному вам описанию метрополитена определит, с каким минимальным числом пересадок можно
добраться со станции A на станцию B. Если данный метрополитен не соединяет все линии в одну систему, то может так получиться,
что со станции A на станцию B добраться невозможно, в этом случае ваша программа должна это определить.

Формат ввода
Сначала вводится число N — количество станций метро в городе (2≤N≤100). Далее следует число M — количество линий метро (1≤M≤20).
Далее идет описание M линий. Описание каждой линии состоит из числа Pi — количество станций на этой линии (2≤Pi≤50) и Pi чисел,
задающих номера станций, через которые проходит линия (ни через какую станцию линия не проходит дважды).

Затем вводятся два различных числа: A — номер начальной станции, и B — номер станции, на которую нам нужно попасть.
При этом если через станцию A проходит несколько линий, то мы можем спуститься на любую из них. Так же если через станцию
B проходит несколько линий, то нам не важно, по какой линии мы приедем.

Формат вывода
Выведите минимальное количество пересадок, которое нам понадобится. Если добраться со станции A на станцию B невозможно,
программа должна вывести одно число –1 (минус один).

Пример
Ввод	Вывод
5
2
4 1 2 3 4
2 5 3
3 1

0*/

import java.util.*;

public class Main {
    static ArrayList<ArrayList<Integer>> lines = new ArrayList<>(); // Список линий
    static int n; // Количество станций метро
    static int a, b; // Номера начальной и конечной станции
    static int[] used; // Массив флагов, помечающих использованные станции
    static int[] dist; // Массив расстояний от начальной станции

    // Обход в ширину
    public static int bfs(int start, int end) {
        used = new int[n + 1];
        dist = new int[n + 1];
        Arrays.fill(dist, -1);

        Queue<Integer> q = new LinkedList<>();
        q.add(start);
        used[start] = 1;
        dist[start] = 0;

        while (!q.isEmpty()) {
            int v = q.poll();

            for (int i = 0; i < lines.size(); i++) {
                if (lines.get(i).contains(v)) {
                    for (int j = 0; j < lines.get(i).size(); j++) {
                        int u = lines.get(i).get(j);

                        if (used[u] == 0) {
                            q.add(u);
                            used[u] = 1;
                            dist[u] = dist[v] + 1;

                            if (u == end) {
                                return dist[end] - 1;
                            }
                        }
                    }
                }
            }
        }

        return -1;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();

        int m = sc.nextInt();

        for (int i = 0; i < m; i++) {
            int p = sc.nextInt();
            ArrayList<Integer> line = new ArrayList<>();

            for (int j = 0; j < p; j++) {
                line.add(sc.nextInt());
            }

            lines.add(line);
        }

        a = sc.nextInt();
        b = sc.nextInt();

        int result = bfs(a, b);

        System.out.println(result);
    }


}

