package DP.DPrays;

/*Луч света в темном царстве
(Время: 1 сек. Память: 16 Мб Сложность: 63%)
Темное царство представляет собой лабиринт N×M, некоторые клетки которого окружены зеркальными стенами, а остальные — пустые. Весь лабиринт также окружен зеркальной стеной. В одной из пустых клеток лабиринта поставили светофор, который испускает лучи в 4 направлениях: под 45 градусов относительно стен лабиринта. Требуется изобразить траекторию этих лучей.

Когда луч приходит в угол, через который проходят зеркальные стены, дальше он идет так, как показано на рисунках (серым цветом показаны клетки, которые окружены зеркальными стенами). Аналогичным образом луч ведет себя, когда приходит на границу лабиринта.

Луч света в темном царстве
Входные данные
В первой строке входного файла INPUT.TXT записаны два натуральных числа N и M — число строк и столбцов в лабиринте (каждое из чисел не меньше 1 и не больше 100). В следующих N строках записано ровно по M символов в каждой — карта лабиринта. Символ * (звездочка) обозначает клетку, окруженную зеркальными стенками, . (точка) — пустую клетку, символ X (заглавная английская буква X) — клетку, в которой расположен светофор (такая клетка ровно одна).

Выходные данные
В выходной файл OUTPUT.TXT выведите N строк по M символов в каждой — изображение лабиринта с траекториями лучей. Здесь, как и раньше, * (звездочка) должна обозначать клетки, окруженные зеркальными стенами, . (точка) — пустые клетки, через которые лучи света не проходят, / (слеш) — клетки, через которые луч света проходит из левого нижнего угла в правый верхний (или обратно — из правого верхнего в левый нижний), \ (обратный слеш) — клетки, через которые луч проходит из левого верхнего угла в правый нижний (или обратно), а символ X (заглавная английская буква X) — клетки, через которые лучи проходят по обеим диагоналям.

Примеры
№	INPUT.TXT	OUTPUT.TXT
5 6
..*...
......
.....*
*X...*
....*.

./*./\
/..X./
\./.X*
*X.//*
/\X/*.


3 3
...
.X.
...

\./
.X.
/.\
 */


import java.util.*;

class Main {
    enum napr { // перечислимый тип для направления
        UR,
        UL,
        DL,
        DR
    }

    static char[][] a = new char[102][102];    // это и есть "царство"

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt(), m = input.nextInt();

        // ввод и заполнение краев '*'
        for (int i = 0; i < n + 2; ++i) {
            for (int j = 0; j < m + 2; ++j) {
                a[i][j] = '*';
            }
        }

        for (int i = 1; i <= n; ++i) {
            String row = input.next();
            for (int j = 1; j <= m; ++j) {
                a[i][j] = row.charAt(j - 1);
            }
        }

        // запускаем лучики из каждой точки верхней грани
        for (int i = 1; i <= m; ++i) {
            ray(1, i, napr.DR);
        }

        // запускаем лучики из каждой точки левой грани
        for (int i = 2; i <= n; ++i) {
            ray(i, 1, napr.UR);
        }

        // запускаем лучики из каждой точки правой грани
        for (int i = 2; i <= n; ++i) {
            ray(i, m, napr.UL);
        }

        // запускаем лучики из каждой точки нижней грани
        for (int i = 1; i <= m; ++i) {
            ray(n, i, napr.UL);
        }

        // выводим ответ
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                System.out.print(a[i][j]);
            }
            System.out.println();
        }
    }



    static void ray(int z, int x, napr napr) {
        //printf1();
        switch (napr){
            case UR: { // вверх-вправо
                if (a[z - 1][x + 1] == '.' && (a[z-1][x] !='*' || a[z][x+1]!='*')) {
                    a[z - 1][x + 1] = '/';
                    ray(z - 1, x + 1, napr.UR); // пошел далее
                    break;
                }
                if (a[z - 1][x + 1] == '\\' && (a[z - 1][x] != '*' || a[z][x + 1] != '*')) {
                    a[z - 1][x + 1] = 'X';
                    ray(z - 1, x + 1, napr.UR); // пошел далее
                    break;
                }
                if (a[z - 1][x + 1] == '*' && a[z][x + 1] == '*' && a[z - 1][x] == '.') {
                    a[z - 1][x] = '\\';
                    ray(z - 1, x, napr.UL); // отразился вверх влево
                    break;
                }
                if (a[z - 1][x + 1] == '*' && a[z][x + 1] == '*' && a[z - 1][x] == '/') {
                    a[z - 1][x] = 'X';
                    ray(z - 1, x, napr.UL); // отразился вверх влево
                    break;
                }
                if (a[z - 1][x] == '*' && a[z-1][x + 1] == '*' && a[z][x+1] == '.') {
                    a[z][x+1] = '\\';
                    ray(z, x + 1, napr.DR); // отразился вниз право
                    break;
                }
                if (a[z - 1][x] == '*' && a[z - 1][x + 1] == '*' && a[z][x + 1] == '/') {
                    a[z][x+1] = 'X';
                    ray(z, x + 1, napr.DR); // отразился вниз право
                    break;
                }
                return;
            }
            case DR: { // вниз-вправо
                if (a[z + 1][x + 1] == '.' && (a[z + 1][x] != '*' || a[z][x + 1] != '*')) {
                    a[z + 1][x + 1] = '\\';
                    ray(z + 1, x + 1, napr.DR); // пошел далее
                    break;
                }
                if (a[z + 1][x + 1] == '/' && (a[z + 1][x] != '*' || a[z][x + 1] != '*')) {
                    a[z + 1][x + 1] = 'X';
                    ray(z + 1, x + 1, napr.DR); // пошел далее
                    break;
                }
                if (a[z + 1][x + 1] == '*' && a[z+1][x] == '*' && a[z][x+1] == '.') {
                    a[z][x+1] = '/';
                    ray(z, x+1, napr.UR); // отразился вверх вправо
                    break;
                }
                if (a[z + 1][x + 1] == '*' && a[z+1][x] == '*' && a[z][x+1] == '\\') {
                    a[z][x+1] = 'X';
                    ray(z, x+1, napr.UR); // отразился вверх вправо
                    break;
                }
                if (a[z + 1][x+1] == '*' && a[z][x + 1] == '*' && a[z+1][x] == '.') {
                    a[z+1][x] = '/';
                    ray(z+1, x, napr.DL); // отразился вниз влево
                    break;
                }
                if (a[z + 1][x + 1] == '*' && a[z][x + 1] == '*' && a[z + 1][x] == '\\') {
                    a[z + 1][x] = 'X';
                    ray(z+1, x, napr.DL); // отразился вниз влево
                    break;
                }
                return;
            }
            case UL: { // вверх-влево
                if (a[z - 1][x - 1] == '.' && (a[z - 1][x] != '*' || a[z][x - 1] != '*')) {
                    a[z - 1][x - 1] = '\\';
                    ray(z - 1, x - 1, napr.UL); // пошел далее
                    break;
                }
                if (a[z - 1][x - 1] == '/' && (a[z - 1][x] != '*' || a[z][x - 1] != '*')) {
                    a[z - 1][x - 1] = 'X';
                    ray(z - 1, x - 1, napr.UL); // пошел далее
                    break;
                }
                if (a[z - 1][x - 1] == '*' && a[z - 1][x] == '*' && a[z][x - 1] == '.') {
                    a[z][x - 1] = '/';
                    ray(z, x - 1, napr.DL); // отразился вниз влево
                    break;
                }
                if (a[z - 1][x - 1] == '*' && a[z - 1][x] == '*' && a[z][x - 1] == '\\') {
                    a[z][x - 1] = 'X';
                    ray(z, x - 1, napr.DL); // отразился вниз влево
                    break;
                }
                if (a[z - 1][x - 1] == '*' && a[z][x - 1] == '*' && a[z - 1][x] == '.') {
                    a[z - 1][x] = '/';
                    ray(z-1, x, napr.UR); // отразился вверх вправо
                    break;
                }
                if (a[z - 1][x - 1] == '*' && a[z][x - 1] == '*' && a[z - 1][x] == '\\') {
                    a[z - 1][x] = 'X';
                    ray(z-1, x, napr.UR); // отразился вверх вправо
                    break;
                }
                return;
            }
            case DL: { // вниз-влево
                if (a[z + 1][x - 1] == '.' && (a[z + 1][x] != '*' || a[z][x - 1] != '*')) {
                    a[z + 1][x - 1] = '/';
                    ray(z + 1, x - 1, napr.DL); // пошел далее
                    break;
                }
                if (a[z + 1][x - 1] == '\\' && (a[z + 1][x] != '*' || a[z][x - 1] != '*')) {
                    a[z + 1][x - 1] = 'X';
                    ray(z + 1, x - 1, napr.DL); // пошел далее
                    break;
                }
                if (a[z][x - 1] == '*' && a[z + 1][x - 1] == '*' && a[z + 1][x] == '.') {
                    a[z + 1][x] = '\\';
                    ray(z + 1, x, napr.DR); // отразился вниз вправо
                    break;
                }
                if (a[z][x - 1] == '*' && a[z + 1][x - 1] == '*' && a[z + 1][x] == '/') {
                    a[z + 1][x] = 'X';
                    ray(z + 1, x, napr.DR); // отразился вниз вправо
                    break;
                }
                if (a[z + 1][x] == '*' && a[z + 1][x - 1] == '*' && a[z][x - 1] == '.') {
                    a[z][x-1] = '\\';
                    ray(z, x-1, napr.UL); // отразился вверх влево
                    break;
                }
                if (a[z + 1][x] == '*' && a[z + 1][x - 1] == '*' && a[z][x - 1] == '/') {
                    a[z][x-1] = 'X';
                    ray(z, x-1, napr.UL); // отразился вверх влево
                    break;
                }
            }
            default: return;
        }
    }


}
